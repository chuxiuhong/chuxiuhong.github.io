<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>衡量轨迹距离算法 - 唯心不易</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="chuxiuhong"><meta name=description content="这篇文章内容主要是来源于[1]这篇文章，这篇文章主要是一篇对衡量轨迹之间相似度的综述论文，在此我总结一下提一提干货。 概念 轨迹采样点：轨迹采样"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.74.2 with theme even"><link rel=canonical href=http://chuxiuhong.com/post/trajectory-distance/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="衡量轨迹距离算法"><meta property="og:description" content="这篇文章内容主要是来源于[1]这篇文章，这篇文章主要是一篇对衡量轨迹之间相似度的综述论文，在此我总结一下提一提干货。 概念 轨迹采样点：轨迹采样"><meta property="og:type" content="article"><meta property="og:url" content="http://chuxiuhong.com/post/trajectory-distance/"><meta property="article:published_time" content="2021-04-15T23:26:22+08:00"><meta property="article:modified_time" content="2021-04-15T23:26:22+08:00"><meta itemprop=name content="衡量轨迹距离算法"><meta itemprop=description content="这篇文章内容主要是来源于[1]这篇文章，这篇文章主要是一篇对衡量轨迹之间相似度的综述论文，在此我总结一下提一提干货。 概念 轨迹采样点：轨迹采样"><meta itemprop=datePublished content="2021-04-15T23:26:22+08:00"><meta itemprop=dateModified content="2021-04-15T23:26:22+08:00"><meta itemprop=wordCount content="3991"><meta itemprop=keywords content="轨迹,算法,"><meta name=twitter:card content="summary"><meta name=twitter:title content="衡量轨迹距离算法"><meta name=twitter:description content="这篇文章内容主要是来源于[1]这篇文章，这篇文章主要是一篇对衡量轨迹之间相似度的综述论文，在此我总结一下提一提干货。 概念 轨迹采样点：轨迹采样"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>唯心不易</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>主页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/about/><li class=mobile-menu-item>关于我</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>唯心不易</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>主页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/about/>关于我</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>衡量轨迹距离算法</h1><div class=post-meta><span class=post-time>2021-04-15</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#概念>概念</a></li><li><a href=#轨迹距离算法分类>轨迹距离算法分类</a></li><li><a href=#欧几里得距离euclidean-distance>欧几里得距离(Euclidean distance)</a></li><li><a href=#dtw距离dynamic-time-warping>DTW距离（Dynamic time warping）</a></li><li><a href=#最长公共子序列距离lcss-distance>最长公共子序列距离（LCSS distance）</a></li><li><a href=#实序列编辑距离edr-distanceedit-distance-on-real-sequence>实序列编辑距离EDR distance（Edit distance on real sequence）</a></li><li><a href=#带惩罚的编辑距离edit-distance-with-real-penalty>带惩罚的编辑距离（Edit distance with real penalty）</a></li><li><a href=#投影编辑距离edit-distance-with-projections>投影编辑距离（Edit distance with projections）</a></li><li><a href=#单向距离one-way-distance>单向距离（One-way distance）</a></li><li><a href=#多边形面积距离locality-in-between-polylines-distance>多边形面积距离（Locality in-between polylines distance）</a></li><li><a href=#距离归并算法merge-distance>距离归并算法（Merge distance）</a></li><li><a href=#时空最长公共子序列距离spatiotemporal-lcss>时空最长公共子序列距离（Spatiotemporal LCSS）</a></li><li><a href=#时空线性结合距离spatiotemporal-linear-combine-distance>时空线性结合距离（Spatiotemporal linear combine distance）</a></li><li><a href=#弗雷歇距离fréchet-distance>弗雷歇距离（Fréchet distance）</a></li><li><a href=#哪种轨迹距离算法更好>哪种轨迹距离算法更好？</a></li></ul></nav></div></div><div class=post-content><p>这篇文章内容主要是来源于[1]这篇文章，这篇文章主要是一篇对衡量轨迹之间相似度的综述论文，在此我总结一下提一提干货。</p><h2 id=概念>概念</h2><p>轨迹采样点：轨迹采样点包括经纬度和时间戳，按照一定规则从实际目标中采样而来，类似于<code>((116.364629,39.940511), 3/1/2012 12:00:31 AM)</code>，具体格式不重要，信息量一样。</p><p>轨迹距离：轨迹距离是衡量轨迹相似度的评价指标，轨迹距离越大，说明两个轨迹差距越大，反之则越相似。</p><p>轨迹距离可度量性：如果一种轨迹距离定义能够符合以下几点，即为具有可度量性：</p><ol><li>非负性：$d(T_1,T_2) \geq 0$</li><li>同一性：$d(T_1,T_2)=0 \Leftrightarrow T_1=T_2$</li><li>对称性：$d(T_1,T_2)= d(T_2,T_1)$</li><li>三角不等性：$d(T_1,T_3) \leq d(T_1,T_2) + d(T_2,T_3)$</li></ol><h2 id=轨迹距离算法分类>轨迹距离算法分类</h2><ol><li>针对离散轨迹or针对连续轨迹</li><li>部分采样点匹配or全部采样点匹配</li><li>是否具有可度量性</li><li>考虑时间信息or仅考虑位置信息</li><li>是否需要手动设置参数</li></ol><p>后面各个算法我也按照这几点总结。</p><p>论文中的分类原图：</p><p><img src=/static/1618503148845.png alt=1618503148845></p><h2 id=欧几里得距离euclidean-distance>欧几里得距离(Euclidean distance)</h2><p>非常经典的距离算法，是我们日常生活中最常用的距离算法了，原版为$d_{Euclidean}(T_1,T_2)=\frac {\Sigma_{i=1}^{n}d(p_{1,i},p_{2,i})} {n}$，不过这里需要两个轨迹的长度完全一致，不一致时匹配方法可以用$d_{Euclidean}(T_1,T_2)=\min \limits_{j=1}^{m-n+1} \frac {\Sigma_{i=1}^{n}d(p_{1,i},p_{2,j+i})} {n}$</p><ul><li>针对离散型轨迹</li><li>全部采样点匹配</li><li>具有可度量性</li><li>仅考虑位置信息</li><li>不需要手动设定参数</li><li>相同长度的版本时间复杂度为$O(n)$，不同长度版本的时间复杂度为$O(mn)$</li><li>对于误差有一定容忍性</li></ul><h2 id=dtw距离dynamic-time-warping>DTW距离（Dynamic time warping）</h2><p>DTW距离是非常经典的序列相似度匹配的算法，之前我在老博客<a href=https://www.cnblogs.com/chuxiuhong/p/6124459.html>命令词识别</a>里详细讲过该算法，并且将该算法用于语音中的命令词识别，有兴趣的可以去看一看。</p><p>这里直接列公式
$$
d_{DTW}(T_1,T_2)=
\begin{align*}
0 & & if \ n = 0 \ and\ m=0 \\<br>& \infty & & if \ n = 0 \ or\ m=0 \\<br>& d(Head(T_1),Head(T_2)+min \{ d_{DTW}(T1,Rest(T_2)),d_{DTW}(Rest(T_1),T_2),d_{DTW}(Rest(T_1),Rest(T_2))\}) & & otherwise\\<br>\end{align*}
$$</p><ul><li>针对离散型轨迹</li><li>全部采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>不需要手动设定参数</li><li>原版DTW的时间复杂度为$O(mn)$，改进速度版本PDTW时间复杂度为$O(\frac {MN} {c^2})$，$c$为抽样间隔</li><li>对于误差有一定容忍性</li></ul><h2 id=最长公共子序列距离lcss-distance>最长公共子序列距离（LCSS distance）</h2><p>LCSS算法是字符串的经典算法，算法导论里也有讲解，在这里的关键在于两个点位之间的匹配。字符串里的字符a仅会和a匹配，而轨迹中的匹配必定是模糊匹配，这就要求设计者要设置点位误差范围，当两个点的距离小于这个误差范围的时候，就当做两个点相同，然后就是LCSS算法的常规操作。
$$
s_{LCSS}(T_1,T_2)=
\begin{align*}
\Phi & & if \ i = 0 \ or\ j=0 \\<br>& s_{LCSS}(Rest(T_1),Rest(T_2))+1 & & if \ d(Head(T_1),Head(T_2)) \leq \epsilon \\<br>& max\{s_{LCSS}(T_1,Rest(T_2)),s_{LCSS}(Rest(T_1),T_2)\} & & otherwise\\<br>\end{align*}
$$</p><p>LCSS距离$d_{LCSS}(T_1,T_2) = size(T_1)+size(T_2)-2*s_{LCSS}(T_1,T_2)$</p><p>正则化的LCSS距离$d_{LCSS}(T_1,T_2) = 1- \frac {s_{LCSS}(T_1,T_2)} {size(T_1)+size(T_2)-2*s_{LCSS}(T_1,T_2)}$</p><ul><li>针对离散型轨迹</li><li>部分采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>需要手动设定参数（点位允许误差）</li><li>时间复杂度为$O(mn)$</li><li>对于误差敏感</li></ul><h2 id=实序列编辑距离edr-distanceedit-distance-on-real-sequence>实序列编辑距离EDR distance（Edit distance on real sequence）</h2><p>EDR算法是基于编辑距离的一种轨迹相似度度量算法，编辑距离算法和前面最长公共子序列一样，原本都是用于字符串相似度匹配的，用于轨迹匹配时，就要进行点位模糊匹配，需要设计者给定一个容许误差范围，在此误差范围内即认为两个点相同。匹配时就按照经典的编辑距离进行度量，其他不变。</p><p>$$
subcost(p_1,p_2) =
\begin{align*}
0, & & d(p_1,p_2) \leq \epsilon \\<br>1, & & otherwise \\<br>\end{align*}
$$</p><p>$$
d_{EDR}(T_1,T_2) =
\begin{align*}
n, & & if \ m = 0 \\<br>m, & & if \ n =0 \\<br>min \ \{ d_{EDR}(Rest(T_1),Rest(T_2))+subcost(Head(T_1),Head(T_2)),
d_{EDR}(Rest(T_1),T_2)+1,d_{EDR}(T_1,Rest(T_2))+1 \} & & otherwise
\end{align*}
$$</p><ul><li>针对离散型轨迹</li><li>部分采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>需要手动设定参数（点位允许误差）</li><li>时间复杂度为$O(mn)$</li><li>对于误差不敏感</li></ul><h2 id=带惩罚的编辑距离edit-distance-with-real-penalty>带惩罚的编辑距离（Edit distance with real penalty）</h2><p>ERP算法也是基于编辑距离的一种算法，它的特点是将编辑距离匹配中的插入、删除操作中缺少值的一方，看作一个<code>gap</code>算子。具体来说，$T_1$和$T_2$匹配，其中如果要对$T_1$插入一个来自于$T_2$的$p_j$使其更接近$T_2$，那么在匹配时$p_j$这个点对应的就是$T_1$的一个<code>gap</code>算子，表示没有对应的值匹配。相反地，如果要对$T_1$删除一个$p_i$来使$T_1$更接近$T_2$，那么匹配时$p_i$这个点对应的就是$T_2$的一个<code>gap</code>算子。在匹配时，这个<code>gap</code>算子的距离需要设计者自己设置。</p><p>编辑距离具体匹配时按照以下规则：</p><p>$$
dist_{ERP}(p_1,p_2) =
\begin{align*}
|p_1 - p_2|, & & if \ p_1,p_2 \ not \ gaps \\<br>|p_1 - g|, & & if \ p_2 \ is \ a \ gap \\<br>|p_2 - g|, & & if \ p_1 \ is \ a \ gap
\end{align*}
$$</p><p>ERP算法的距离表示为</p><p>$$
d_{ERP}(p_1,p_2) =
\begin{align*}
\Sigma_{1}^{n}dist_{ERP}(p_{1,i},g), & & if \ m = 0 \\<br>\Sigma_{1}^{m}dist_{ERP}(p_{2,i},g), & & if \ n = 0 \\<br>min\{d_{ERP}(Rest(T_1),Rest(T_2))+dist_{ERP}(Head(T_1),Head(T_2)), \\<br>d_{ERP}(Rest(T_1),T_2)+dist_{ERP}(Head(T_1),g),\\<br>d_ERP(T_1,Rest(T_2))+dist_{ERP}(Head(T_2),g)\}, & & otherwise
\end{align*}
$$</p><ul><li>针对离散型轨迹</li><li>部分采样点匹配</li><li>具有可度量性</li><li>仅考虑位置信息</li><li>需要手动设定参数(<code>gap</code>值)</li><li>时间复杂度为$O(mn)$</li><li>对误差不敏感</li></ul><h2 id=投影编辑距离edit-distance-with-projections>投影编辑距离（Edit distance with projections）</h2><p>这个我个人感觉糟的一塌糊涂，实无应用之可能，有兴趣自己查吧</p><h2 id=单向距离one-way-distance>单向距离（One-way distance）</h2><p>这算法的核心宗旨是计算在$T_1$上的每个点到$T_2$的最短距离，然后求平均值（自己愿意也可以加权）。点到轨迹的最短距离就取轨迹上与这个点最近的一个点，然后计算这两个点的距离当做点到轨迹的距离。很明显，这样一来$T_1$到$T_2$的距离可未必等于$T_2$到$T_1$的距离。公式表示如下：</p><p>$点到轨迹距离d_{point}(p,T) = \min\limits_{p&rsquo; \in T}d(p,p&rsquo;)$</p><p>$单向距离d_{owd}(T_1 \rightarrow T) = \frac {1} {Size(T_1)} *\mathop\Sigma\limits_{p \in T_1} d_{point}(p,T_2)$</p><p>$双向距离d_{OWD}(T_1,T_2) = 0.5 * (d_{owd}(T_1 \rightarrow T_2) + d_{owd}(T_2 \rightarrow T_1)$</p><ul><li>离散连续均可</li><li>所有采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>不需要手动设定参数</li><li>时间复杂度为$O(mn)$</li><li>对误差不敏感</li></ul><h2 id=多边形面积距离locality-in-between-polylines-distance>多边形面积距离（Locality in-between polylines distance）</h2><p>这个算法跳出了前面将轨迹计算化为点的计算的模式，改为计算两个轨迹之间围成的多边形的面积。</p><p><img src=/static/1618817319610.png alt=1618817319610></p><p>$d_{LIP}(T_1,T_2) = \mathop\Sigma\limits_{\forall polygon_i}Area_i * w_i$</p><p>$w_k = \frac {Length_{T_1}(i_k,i_{k+1}) + Length_{T_2}(i_k,i_{k+1})} {Length(T_1) + Length(T_2)}$</p><p>这个算法就相当于计算差异面积的加权和。不过对于下面这两种情况没办法正确计算：</p><p><img src=/static/1618817859722.png alt=1618817859722></p><ul><li>离散连续均可</li><li>所有采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>不需要手动设定参数</li><li>时间复杂度为$O((m+n) * log(m+n))$</li><li>对误差敏感度较高</li></ul><h2 id=距离归并算法merge-distance>距离归并算法（Merge distance）</h2><p>这个算法的核心是把两个轨迹合并成一个中间轨迹，然后计算这个中间轨迹和两条原轨迹的差异作为两条轨迹的距离。</p><p><img src=/static/1618818812289.png alt=1618818812289></p><p><img src=/static/1618818856530.png alt=1618818856530></p><p>$d_{MD}(T_1,T_2) = \frac {Length(T_{super})} {Length(T_1) + Length(T_2)} - 1$</p><ul><li>离散连续均可</li><li>所有采样点匹配</li><li>不具有可度量性</li><li>仅考虑位置信息</li><li>不需要手动设定参数</li><li>时间复杂度为$O(mn)$</li><li>对于误差有一定容忍性</li></ul><h2 id=时空最长公共子序列距离spatiotemporal-lcss>时空最长公共子序列距离（Spatiotemporal LCSS）</h2><p>和前面的最长公共子序列距离很类似，不过这回增加考虑了时间这个因素。原本是设定一个距离误差范围，小于这个误差范围的就算这两个点匹配上了。现在是再增加一个时间误差范围，在前面的要求上额外要求时间差必须在这个误差范围才算匹配得上。</p><p>设$\epsilon$为距离误差范围，$\delta$为时间误差范围，匹配方式如下图所示：</p><p><img src=/static/1618819637835.png alt=1618819637835></p><p><img src=/static/1618819746963.png alt=1618819746963></p><p>$d_{STLCSS}(T_1,T_2) = 1 - \frac {s_{STLCSS}(T_1,T_2)} {min(n,m)}$</p><ul><li>针对离散型轨迹</li><li>部分采样点匹配</li><li>不具有可度量性</li><li>同时考虑时间和位置信息</li><li>需要手动设定参数</li><li>时间复杂度为$O(mn)$</li><li>对于误差有一定容忍性</li></ul><h2 id=时空线性结合距离spatiotemporal-linear-combine-distance>时空线性结合距离（Spatiotemporal linear combine distance）</h2><p>这个算法的思路是将时间和时间匹配、位置和位置匹配，最后按照一定权值线性组合起时间距离和空间距离，作为总体的轨迹距离。</p><p>$d_{spa}(p,T) = \min\limits_{p&rsquo; \in T}{d(p,p&rsquo;)}$</p><p>$d_{tem}(p,T) = \min\limits_{p&rsquo; \in T}{|p_{.t} - p&rsquo;_{.t}|}$</p><p>$s_{spa}(T_1,T_2) = \frac {\Sigma_{p \in T_1}e^{-d_{spa}(p,T_2)}} {Size(T_1)} + \frac {\Sigma_{p \in T_2}e^{-d_{spa}(p,T_1)}} {Size(T_2)}$</p><p>$s_{tem}(T_1,T_2) = \frac {\Sigma_{p \in T_1}e^{-d_{tem}(p,T_2)}} {Size(T_1)} + \frac {\Sigma_{p \in T_2}e^{-d_{tem}(p,T_1)}} {Size(T_2)}$</p><p>$s_{spa}和s_{tem}的取值都在[0,2]区间$</p><p>$d_{STLC}(T_1,T_2) = \lambda*s_{spa}(T_1,T_2) + (1-\lambda)*s_{tem}(T_1,T_2)$</p><p>这里的$\lambda$是线性组合的加权值，$\lambda \in [0,1]$，表示空间距离和时间距离的权重设置。</p><ul><li>针对离散型轨迹</li><li>全部采样点匹配</li><li>不具有可度量性</li><li>同时考虑时间和位置信息</li><li>需要手动设定参数</li><li>时间复杂度为$O(mn)$</li><li>对于误差有一定容忍性</li></ul><h2 id=弗雷歇距离fréchet-distance>弗雷歇距离（Fréchet distance）</h2><p>首先要说这个算法是针对连续的曲线进行匹配，其次是这个算法把匹配的距离和采样方式合并在一起考虑。</p><p><img src=/static/1618820691038.png alt=1618820691038></p><p>通俗地讲，要做匹配，咱先得想想如何采样？因为不采样就不能进行点位之间的计算。先这样想，我们任取一种采样方式，这个时候就和前面两个离散轨迹匹配问题是一样的了。然后计算同一时刻的两个轨迹上对应的采样点之间的距离，这时会有许多个点位对的距离值，取其中最大的一个作为这种采样方式下的两个轨迹的距离。那么回到采样方式上，我们就选取让轨迹距离最小化的时候的采样方式作为最后的采样方式。</p><p>看到网上还有种更简单的说法，这个算法的距离相当于遛狗的时候狗绳的长度，不管狗是近是远，最大距离就是狗绳的长度。</p><p>写成公式如下所示：</p><p>$d_{Fréchet}(T_1,T_2) = inf \max\limits_{t \in [t.start,t.end]}{d(f_1(t),f_2(t))}$</p><ul><li>针对连续型轨迹</li><li>部分采样点匹配</li><li>不具有可度量性</li><li>同时考虑时间和位置信息</li><li>不需要手动设定参数</li><li>时间复杂度为$O(mn)$</li><li>对于误差敏感</li></ul><p>其他还有一些连续轨迹型的算法，在这就不写了。</p><h2 id=哪种轨迹距离算法更好>哪种轨迹距离算法更好？</h2><p>这篇文章这一节设计很有意思，因为上面这些算法从解决问题思路方式、匹配采样点模式、是否具有可度量性、是否考虑时间信息、是否需要额外设定参数等等差距极大，甚至连相似度的范围都有所不同，很难比较哪种算法更好。</p><p>于是文章作者想到了自己通过创造数据集来测试，数据集分为原始数据集和做过变换过的数据集，原始数据集为一些轨迹的集合，变换数据集为原始数据集中的轨迹进行变换操作后得到的略有差别的轨迹。变换操作主要有增加采样点、减少采样点、改变采样率、平移变换、增加噪声点这几种方式。如果一种轨迹距离算法可以把原始数据集和变换数据集中原本相同的轨迹匹配在一起，那就说明这种算法更理想。</p><p>一堆比较结果就不提了，按照这篇文章的说法，STLC算法在各个方面匹配度都高于其他算法，同时考虑到这些算法的时间复杂度大差不差一般都是$O(mn)$，所以一般情况下使用STLC算法可能是最合适的。</p><p>参考文献：</p><p>[1] :Su, H., Liu, S., Zheng, B. <em>et al.</em> A survey of trajectory distance measures and performance evaluation. <em>The VLDB Journal</em> <strong>29,</strong> 3–32 (2020). <a href=https://doi.org/10.1007/s00778-019-00574-9>https://doi.org/10.1007/s00778-019-00574-9</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>chuxiuhong</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-04-15</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E8%BD%A8%E8%BF%B9/>轨迹</a>
<a href=/tags/%E7%AE%97%E6%B3%95/>算法</a></div><nav class=post-nav><a class=prev href=/post/rsgeo/><i class="iconfont icon-left"></i><span class="prev-text nav-default">发布一个地理计算库rsgeo</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/postgresql-table-partitioning/><span class="next-text nav-default">Postgresql数据库分表</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:chuxiuhong@chuxiuhong.com class="iconfont icon-email" title=email></a><a href=http://github.com/chuxiuhong class="iconfont icon-github" title=github></a><a href=http://chuxiuhong.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2021
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>chuxiuhong</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$'],['\\(','\\)']]},showProcessingMessages:false,messageStyle:'none'};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin=anonymous></script></body></html>